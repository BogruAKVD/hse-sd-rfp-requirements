# Улучшения странной диаграммы классов

### Визуальное оформление
**Проблема:**  
Расстоянием между блоками слишком большое по сравнению с шрифтом. Большое количество пересечений в связях.  
**Решение:**  
Уменьшить интервалы между блоками. Выровнять их по сетке. Расположить диаграмму в ландшафтном формате. Минимизируя число пересечений связей, скомпозировать блоки так, чтобы был читаем весь текст, и вся диаграмма помещалась на одном экране. При необходимости изменить размер шрифта.


### Некорректное разделение ролей бригадира и рабочего. 
**Почему плохо:**  
У них разные обязанности, например бригадир должен уметь назначать ремонт конкретному рабочему, получать отчет в конце смены.  
**Решение:**  
Создать новый класс для бригадира, возможно отнаследовать от общего класса работника, скорее всего в системе будут какие-то общие методы\поля для всех сотрудников.


### Defect: defectLocation - string
**Почему плохо:**  
Места поломок могут повторяться. Хранение строки не позволяет собирать статистику по местам поломки и подбирать решение на основе предыдущих, так как одно и то же место может быть записано по-разному.  
**Решение:**  
Завести класс `CarPart`, в котором сохранялась бы информация о конкретной части машины.

### Car: model: string
**Почему плохо:**  
В рамках поставки заказывается определенное количество машин конкретной модели в фиксированной комплектации. Выделение модели автомобиля с комплектацией в отдельную сущность позволит избежать проблем, если будет уточнение информации по конкретной поставке, достаточно будет изменить только информацию о модели с комплектацией, а не строку в каждом экземпляре машины.  
**Решение:**  
Выделить модели автомобиля с комплектацией в отдельную сущность.

### RepairZone: numberOfPlaces :: int
**Почему плохо:**  
Непонятно зачем хранить число мест, когда это просто `repairPlaces.size()`. Можно забыть обновить значение какой-то из переменных. Число мест не может быть отрицательным, поэтому лучше использовать беззнаковый тип.  
**Решение:**  
Не хранить переменные, а высчитывать размер `List<RepairPlaces>`.

### ShiftReport: totalRepairTime: float
**Почему плохо:**  
Операции с числами с плавающей точкой работают медленнее, а представление таких чисел не является точным.  
**Решение:**  
Хранить целое число — число секунд.

### AccountingReport: workerShiftDetails: List<String>
**Почему плохо:**  
Отчет по каждому ремонтнику всех ремонтных бригад о количестве отработанных смен, при этом в `List<String>` неудобно хранить, как работника (тип `Worker`), так и число отработанных смен (целое число).  
**Решение:**  
Убрать `workerShiftDetails: List<String>`, добавить поля `worker Worker` и `shiftsWorkedNumber unsigned int` — число отработанных смен.

### RepairTeam: shiftTime: string
**Почему плохо:**  
Хранение информации о времени (начала и конца смены) в строковом, а не временном формате не позволяет производить операции над датами (например, сравнение).  
**Решение:**  
Заменить `string` на типы данных, хранящий дату и время.

### RepairTeam: teamWorkers:: List<Worker>
**Почему плохо:**  
Хранение информации о каждом работнике избыточно.  
**Решение:**  
Заменить на список идентификаторов рабочих `workerIds`.

### Связь `Order -> ProductionPlan`
**Почему плохо:**  
С точки зрения производственных процессов, план должен содержать несколько заказов, так как это более глобальная сущность, определяющая работу всего конвейера. Например, пришло несколько заказов, но детали для второго появятся только после отправки на покраску первого. Логично отмечать это в плане.  
**Решение:**  
Инвертировать связь.

